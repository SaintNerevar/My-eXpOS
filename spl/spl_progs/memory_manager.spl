alias functionNum R1;

if (functionNum == GET_FREE_PAGE) then
    alias currentPID R2;
    alias process_table_entry R3;
    currentPID = [SYSTEM_STATUS_TABLE + 1];
    process_table_entry = PROCESS_TABLE + currentPID*16;

    [SYSTEM_STATUS_TABLE + 3] = [SYSTEM_STATUS_TABLE + 3] + 1;
    while ([SYSTEM_STATUS_TABLE + 2] == 0) do
        [process_table_entry + 4] = WAIT_MEM;

        multipush(R1, R2, R3);
        call SCHEDULER;
        multipop(R1, R2, R3);
    endwhile;
    [SYSTEM_STATUS_TABLE + 3] = [SYSTEM_STATUS_TABLE + 3] - 1;

    alias pageNum R4;
    pageNum = 0;
    while (pageNum < MAX_MEM_PAGE) do
        if ([MEMORY_FREE_LIST + pageNum] == 0) then
            [MEMORY_FREE_LIST + pageNum] = [MEMORY_FREE_LIST + pageNum] + 1;
            R0 = pageNum;
            [SYSTEM_STATUS_TABLE + 2] = [SYSTEM_STATUS_TABLE + 2] - 1;
            break;
        endif;
        pageNum = pageNum + 1;
    endwhile;
    breakpoint;
    return;
endif;

if (functionNum == RELEASE_PAGE) then
    alias pageNum R2;
    alias memory_free_list_entry R3;
    memory_free_list_entry = MEMORY_FREE_LIST + pageNum;

    [memory_free_list_entry] = [memory_free_list_entry] - 1;
    if ([memory_free_list_entry] == 0) then
        [SYSTEM_STATUS_TABLE + 2] = [SYSTEM_STATUS_TABLE + 2] + 1;
    endif;

    alias currentPID R3;
    alias process_table_entry R4;
    currentPID = 0;
    while(currentPID < 16) do
        process_table_entry = PROCESS_TABLE + currentPID*16;
        if ([process_table_entry + 1] >= 0 && [process_table_entry + 4] == WAIT_MEM) then
            [process_table_entry + 4] = READY;
        endif;
        currentPID = currentPID + 1;
    endwhile;
    return;
    breakpoint;
endif;