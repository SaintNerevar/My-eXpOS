[PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1]*16 + 9] = 9;

alias userSP R0;
alias process_table_entry R1;
userSP = SP;
process_table_entry = PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1]*16;

[process_table_entry + 13] = SP;
SP = [process_table_entry + 11]*512 - 1;

alias physicalPageNum R2;
alias offset R3;
alias filename R4;
physicalPageNum = [PTBR + 2*((userSP - 4)/512)];
offset = (userSP - 4) % 512;
filename = [physicalPageNum*512 + offset];

//Get inode entry of filename
alias inode_entry R5;
alias fileNum R6;
fileNum = 1;
while (fileNum < MAX_FILE_NUM) do
    inode_entry = INODE_TABLE + fileNum*16;
    if (EXEC == [inode_entry] && [inode_entry + 1] == filename) then
        //breaks only if filename is found and is in XEXE
        break;
    endif;
    fileNum = fileNum + 1;
endwhile;

if (fileNum != MAX_FILE_NUM) then
    //Exit current process
    multipush(R0, R1, R2, R3, R4, R5, R6);
    R1 = EXIT_PROCESS;
    R2 = [SYSTEM_STATUS_TABLE + 1];
    call PROCESS_MANAGER;
    multipop(R0, R1, R2, R3, R4, R5, R6);

    //Reclaim same User Area Page and initialize kernel SP
    [MEMORY_FREE_LIST + [process_table_entry + 11]] = [MEMORY_FREE_LIST + [process_table_entry + 11]] + 1;
    [SYSTEM_STATUS_TABLE + 2] = [SYSTEM_STATUS_TABLE + 2] - 1;
    SP = [process_table_entry + 11]*512 - 1;

    [process_table_entry + 7] = inode_entry;
    [process_table_entry + 4] = RUNNING;
    [process_table_entry + 13] = 8*512;

    //Shared Library
    [PTBR] = 63;
    [PTBR + 1] = "0100";
    [PTBR + 2] = 64;
    [PTBR + 3] = "0100";

    //Heap
    multipush(R0, R1, R2, R3, R4, R5, R6);
    R1 = GET_FREE_PAGE;
    call MEMORY_MANAGER;
    [PTBR + 4] = R0;
    [PTBR + 5] = "0110";
    multipop(R0, R1, R2, R3, R4, R5, R6);

    multipush(R0, R1, R2, R3, R4, R5, R6);
    R1 = GET_FREE_PAGE;
    call MEMORY_MANAGER;
    [PTBR + 6] = R0;
    [PTBR + 7] = "0110";
    multipop(R0, R1, R2, R3, R4, R5, R6);

    //Stack
    multipush(R0, R1, R2, R3, R4, R5, R6);
    R1 = GET_FREE_PAGE;
    call MEMORY_MANAGER;
    [PTBR + 16] = R0;
    [PTBR + 17] = "0110";
    multipop(R0, R1, R2, R3, R4, R5, R6);

    multipush(R0, R1, R2, R3, R4, R5, R6);
    R1 = GET_FREE_PAGE;
    call MEMORY_MANAGER;
    [PTBR + 18] = R0;
    [PTBR + 19] = "0110";
    multipop(R0, R1, R2, R3, R4, R5, R6);

    //Allocate memory for and load code blocks
    alias counter R7;
    alias diskBlock R8;
    alias freePage R9;
    counter = 0;
    while (counter < 4) do
        diskBlock = [inode_entry + 8 + counter];
        if (diskBlock != -1) then
            multipush(R0, R1, R2, R3, R4, R5, R6, R7, R8);
            R1 = GET_FREE_PAGE;
            call MEMORY_MANAGER;
            freePage = R0;
            multipop(R0, R1, R2, R3, R4, R5, R6, R7, R8);

            multipush(R0, R1, R2, R3, R4, R5, R6, R7, R8, R9);
            R1 = DISK_LOAD;
            R2 = [SYSTEM_STATUS_TABLE + 1]; //Might cause problems. Look out
            R3 = freePage;
            R4 = diskBlock;
            call DEVICE_MANAGER;
            multipop(R0, R1, R2, R3, R4, R5, R6, R7, R8, R9);

            [PTBR + 2*(counter + 4)] = freePage;
            [PTBR + 2*(counter + 4) + 1] = "0100";
        endif;
        counter = counter + 1;
    endwhile;

    //Set user stack pointer to code
    [[PTBR + 16]*512] = [[PTBR + 8]*512 + 1];

    //initialize Per-Process Resource Table
    counter = 0;
    while (counter < 16) do
        [[process_table_entry + 11]*512 + 496 + counter] = -1;
        counter = counter + 1;
    endwhile;
else
    physicalPageNum = [PTBR + 2*((userSP - 1)/512)];
    offset = (userSP - 1) % 512;
    [physicalPageNum*512 + offset] = -1;
endif;

[PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1]*16 + 9] = 0;
SP = 8*512;
ireturn;